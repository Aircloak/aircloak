title: An introduction to writing queries
order: 1
content: |

  # An introduction to writing queries

  A query is a task that generates reports based on user data residing in the database.

  Due to the mechanisms put in place to provide a high levels of user anonymity
  and privacy, the way in which you write queries against our system
  most likely differs quite significantly from how you today query your
  other database systems.

  The queries you write have to be of the kind that return an aggregate count.
  For example _how many users were at a location at a given time_, the answer to
  which might be 50.

  Instead of writing queries that have access to all the data in the
  database _at the same time_, you write queries that deal with the data of
  users _individually_.

  The queries are stateless. This means that when a query
  runs over user _Bob_ it has no notion of what it might previously
  have seen and computed about _Dylan_.

  When a query is executed, it has to make local decisions
  based on the data of the individual user about whether
  the user should be included in the resulting count, or not.

  For explanation of different task execution models see <%= help_link "task-execution"%>

  For a more in-depth explanation of how to think about the query model,
  take a look at <%= help_link "understanding-the-query-model" %>.


  ## Queries are executed in three steps:

  1. The data needed by the query is collected by the cloak
  2. The query code is run once per user and is given the data of the user it is executing over.
    The query needs to make a per user decision if something should be reported or not.
  3. The results of the query run over all users is aggregated, anonymized, and returned from the cloak

  ### Data pre-selection

  In the query interface you select which database tables you want to have access
  to in your query. You can also filter the data returned for a table by specifying constraints.
  For example only __<%= sample_user_table_name %>__ where __<%= sample_constraint %>__.

  You can also specify that you only want the last __N__ results per user, or
  only results that arrived at the cloak within a certain number of minutes. The more you can
  restrict the dataset over which the query runs, the faster the query will
  be able to finish. This is especially important if you write queries that
  execute frequently, for example to provide a real-time input for a dashboard,
  or decision making system.

  When you limit the number of results returned per user, the limit is applied last, __after__
  other filters have been applied. The order of the results is as it was when the data was
  inserted into the cloak by the user.

  The filter that allows you to limit the results to data from the last __N__ minutes,
  performs filtering based on __the time at which the data arrived at the cloak__.
  Any timestamp field or other field with semantic value in the data itself is ignored.
  Therefore if you upload data that was recorded an hour ago, have a query that operates
  on data from the last five minutes, and the query runs a minute after the data was uploaded,
  it will receive the hour old data. Therefore you additionally need to consider semantic
  timestamp values in your query code itself, and there make decisions as to how you
  handle old data.

  ### Queries

  The queries are written in __Lua__.
  Basic familiarity with __Lua__ will be helpful.
  For a lightning quick introduction, or refresher, to Lua, you can check out this
  15 minute introduction: http://tylerneylon.com/a/learn-lua/

  #### Accessing data

  In your queries you access the data from the pre-selection queries using the
  `tables` lua table.
  For example to get access to the data from the __<%= sample_user_table_name %>__
  table, you would issue the command `tables.<%= sample_user_table_name %>`.

  The data returned is in an array. Even when there is only a single row of data returned.

  Looping through these can easily be done as follows:

  ```Lua
  <%= sample_user_table_name %> = tables.<%= sample_user_table_name %>
  for i = 1, #<%= sample_user_table_name %> do
    item = <%= sample_user_table_name %>[i]
    process(item) -- where `process` is a function implemented by you
  end
  ```

  You might have noticed that the we index the array starting at 1, rather than 0.
  This is because Lua, contrary to most other programming languages, indices arrays from 1 rather than 0.

  You can also query a lookup table (see <%= help_link "lookup-tables" %>),
  by calling `lookup(table_name, key)` which will return the corresponding value.

  It is worth mentioning that there is a global `user_id` variable available containing the id of the
  user being processed.


  #### Working with times

  The best way to deal with times is to use [epoch time](http://en.wikipedia.org/wiki/Unix_time) (number of seconds passed since
  00:00:00, January 1st, 1970.). It is advised you use a `varchar(10)` as the corresponding data type.

  You can deal with epoch time in Lua scripts using the `to_date` provided function. The result of a call to
  `to_date` is a Lua table with following fields:

  - `year`, `month`, `day`
  - `hour`, `min`, `sec`
  - `wday` (day of the week, 1=Sunday, 2=Monday, ...)
  - `yday` (day of the year in range of 1-366)

  Some helper functions exist that can help you manipulate such tables. For more details, see
  <%= help_link "query-library" %>.

  #### Reporting values

  Whenever you want to report a value for a given user, you can use the `report_property` function.
  It takes two parameters: a __name__ and a __value__.

  You can think of it as follows: The cloak counts how many users report the exact same __name-value__ pair.
  What you get returned from the cloak are effectively __(name, value, count)__-triplets.

  ##### Example

  If you have the age of a user, you could report _"age"_ as the name, and the _age value_ as the value.
  You would then get reported triplets showing how many users have the distinct age values.

  In Lua, this would look like `report_property("age", age)`, assuming you have the users age stored in
  a variable called `age`.

  Alternatively, for a user of age 29, you could also report the name "age" and the value "between 20 and 30".
  The benefit of the latter approach can be hard to get an intuition for, but is quite important.
  The cloaks filter results where the count is too low. If there are particular age ranges
  where you only have very few users, they would therefore not be reported at all. As an analyst
  you would not know if this was due to there being no users in these age ranges, or only very few.
  By grouping ages together into larger age segments, the chances of there being enough users within
  an age group, and hence the group being reported, increases.
  If you find it hard to get an intuition for this, feel free to send us an email at support@aircloak.com,
  and we will do our best to explain it in terms of your particular user case!


  #### Results

  The primary way to run a query is by executing it from the web interface.
  The web interface also shows the latest results.
  You can download the complete result set as a CSV file if you want to perform post processing
  of the data on your own computer.

  For programmatic access to task execution results, please consult the <%= site_link "/apidocs/index.html", "API Docs" %>.
