defmodule Air.PsqlServer.CloakQuery do
  @moduledoc "Asynchronous execution of queries on the cloak."
  require Logger
  alias Air.PsqlServer.{ConnectionRegistry, Protocol, RanchServer}
  alias Air.Service.DataSource

  # -------------------------------------------------------------------
  # API functions
  # -------------------------------------------------------------------

  @doc "Asynchronously runs a query on the cloak."
  @spec run_query(
          RanchServer.t(),
          String.t(),
          [Protocol.db_value()] | nil,
          (RanchServer.t(), any -> RanchServer.t())
        ) :: :ok
  def run_query(conn, statement, params, on_success) do
    %{data_source_id: data_source_id, user: user, key_data: key_data} = conn.assigns

    with {:ok, query} <- create_query(data_source_id, user, statement, convert_params(params)) do
      ConnectionRegistry.register_query(key_data, user.id, query.id)

      RanchServer.run_async(
        fn -> query |> DataSource.run_query(data_source_id) |> decode_cloak_query_result() end,
        on_success: on_success,
        on_failure: fn conn, _exit_reason -> RanchServer.query_result(conn, {:error, "query failed"}) end
      )
    end
  end

  @doc "Asynchronously describes a query via cloak."
  @spec describe_query(RanchServer.t(), String.t(), [Protocol.param_with_type()] | nil) :: :ok
  def describe_query(conn, query, params) do
    user = conn.assigns.user
    data_source_id = conn.assigns.data_source_id
    converted_params = convert_params(params)
    job_fun = fn -> DataSource.describe_query(data_source_id, user, query, converted_params) end

    result_handler = fn conn, describe_result ->
      result =
        case decode_cloak_query_result(describe_result) do
          {:error, _} = error ->
            error

          parsed_response ->
            Keyword.take(parsed_response, [:columns, :param_types, :info_messages])
        end

      RanchServer.describe_result(conn, result)
    end

    RanchServer.run_async(
      job_fun,
      on_success: result_handler,
      on_failure: fn conn, _exit_reason -> RanchServer.describe_result(conn, {:error, "parsing failed"}) end
    )
  end

  # -------------------------------------------------------------------
  # Internal functions
  # -------------------------------------------------------------------

  defp convert_params(nil), do: nil

  defp convert_params(params),
    do: Enum.map(params, fn {type, value} -> %{type: sql_type(type, value), value: value} end)

  defp create_query(data_source_id, user, statement, parameters) do
    Air.Service.Query.create(
      data_source_id,
      :autogenerate,
      user,
      :psql,
      statement,
      parameters,
      _options = []
    )
  end

  defp decode_cloak_query_result(query_response), do: do_decode_cloak_query_result(query_response)

  defp do_decode_cloak_query_result({:error, :cancelled}), do: {:error, :query_cancelled}

  defp do_decode_cloak_query_result({:error, :query_died}), do: {:error, {:fatal, "The query terminated unexpectedly."}}

  defp do_decode_cloak_query_result({:error, :not_connected}), do: {:error, "Data source is not available!"}

  defp do_decode_cloak_query_result({:error, :license_invalid}),
    do: {:error, "The license for this Aircloak instance has expired."}

  defp do_decode_cloak_query_result({:ok, %{error: error}}), do: {:error, error}

  defp do_decode_cloak_query_result({:ok, query_result}),
    do: [
      columns:
        Enum.zip(query_result.columns, query_result.features.selected_types)
        |> Enum.map(fn {name, sql_type} -> %{name: name, type: psql_type(sql_type)} end),
      rows:
        query_result
        |> Map.get(:buckets, [])
        |> Enum.map(&normalize_anonymized(&1, query_result.features.selected_types))
        |> Air.Schemas.ResultChunk.rows(),
      param_types: Enum.map(query_result.features.parameter_types, &psql_type/1),
      info_messages: Map.get(query_result, :info, [])
    ]

  defp do_decode_cloak_query_result(other) do
    Logger.error("Error running a query: #{inspect(other)}")
    {:error, "System error!"}
  end

  defp normalize_anonymized(bucket, selected_types) do
    Map.update!(bucket, "row", fn row ->
      row
      |> Enum.zip(selected_types)
      |> Enum.map(&normalize_anonymized/1)
    end)
  end

  # Quick fix for problems outlined in https://github.com/Aircloak/aircloak/issues/1378.
  # Note that this is not a proper solution, since we can't distinguish from a regular "*" and a "*" generated by
  # the anonymizer. To properly distinguish these two cases, the cloak should send additional info to indicate whether
  # the "*" value is produced by the anonymizer.
  defp normalize_anonymized({"*", "text"}), do: "*"
  defp normalize_anonymized({"*", _other_type}), do: nil
  defp normalize_anonymized({other_value, _other_type}), do: other_value

  for {psql_type, sql_type} <- %{
        boolean: :boolean,
        int2: :integer,
        int4: :integer,
        int8: :integer,
        float4: :real,
        float8: :real,
        numeric: :real,
        date: :date,
        time: :time,
        timestamp: :datetime,
        text: :text,
        varchar: :text
      } do
    defp sql_type(unquote(psql_type), _value), do: unquote(sql_type)
  end

  defp sql_type(:unknown, value), do: sql_type_from_value(value)

  defp sql_type_from_value(value) when is_boolean(value), do: :boolean
  defp sql_type_from_value(value) when is_integer(value), do: :integer
  defp sql_type_from_value(value) when is_float(value), do: :real
  defp sql_type_from_value(value) when is_binary(value), do: :text
  defp sql_type_from_value(%Date{}), do: :date
  defp sql_type_from_value(%Time{}), do: :time
  defp sql_type_from_value(%NaiveDateTime{}), do: :datetime

  defp psql_type(type_string), do: psql_type_impl(type_string)

  for {sql_type, psql_type} <- %{
        "boolean" => :boolean,
        "integer" => :int8,
        "real" => :float8,
        "text" => :text,
        "date" => :date,
        "time" => :time,
        "datetime" => :timestamp
      } do
    defp psql_type_impl(unquote(sql_type)), do: unquote(psql_type)
  end

  defp psql_type_impl(_other), do: :unknown
end
