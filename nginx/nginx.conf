worker_processes  1;

daemon off;

events {
  worker_connections  1024;
  multi_accept on;
}

http {
  # extract the parent type from the issuer's certificate's distinguished name
  map $ssl_client_i_dn $key_type {
    default "unknown";
    ~(.*?)/CN=air_web_api(.*)? "web_api";
  }

  # extract the analyst id from the client's certificate's distinguished name
  map $ssl_client_s_dn $analyst_token {
    default "";
    ~(.*?)/CN=analyst_token:(?<token>[^/]+)(/.*)? $token;
  }

  sendfile        on;

  keepalive_timeout  0;
  tcp_nodelay        on;

  gzip  on;
  gzip_disable "MSIE [1-6]\.(?!.*SV1)";

  ## ------------------------------------------------------------------
  ## hello and normal frontend
  ## ------------------------------------------------------------------
  server {
    listen *:5500;

    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

    # enable this if you forward HTTPS traffic to unicorn,
    # this helps Rack set the proper URL scheme for doing redirects:
    proxy_set_header X-Forwarded-Proto $scheme;

    # pass the Host: header from the client right along so redirects
    # can be set properly within the Rack application
    proxy_set_header Host $http_host;

    # we don't want nginx trying to do something clever with
    # redirects, we set the Host: header above already.
    proxy_redirect off;

    location /backend/ {
      proxy_pass http://127.0.0.1:11000/backend/;
    }

    location / {
      proxy_pass http://127.0.0.1:3000/;
    }
  }

  ## ------------------------------------------------------------------
  ## api
  ## ------------------------------------------------------------------
  server {
    listen *:5600 ssl;

    ssl on;
    ssl_certificate test.crt;
    ssl_certificate_key test.key;
    ssl_client_certificate api.cert;
    ssl_verify_client on;
    ssl_verify_depth 1; # no intermediate CA accepted

    ssl_session_cache builtin:1000  shared:SSL:10m;
    ssl_session_timeout 5m;
    ssl_ecdh_curve secp521r1;

    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
    ssl_prefer_server_ciphers on;

      # The following is all one long line. We use an explicit list of ciphers to enable
      # forward secrecy without exposing ciphers vulnerable to the BEAST attack
    ssl_ciphers ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-RC4-SHA:ECDHE-RSA-RC4-SHA:ECDH-ECDSA-RC4-SHA:ECDH-RSA-RC4-SHA:ECDHE-RSA-AES256-SHA:RC4-SHA:HIGH:!aNULL:!eNULL:!LOW:!3DES:!MD5:!EXP:!CBC:!EDH:!kEDH:!PSK:!SRP:!kECDH;

      # The following is for reference. It needs to be specified again
      # in each virtualhost, in both HTTP and non-HTTP versions.
    add_header Strict-Transport-Security max-age=2592000;

    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

    # enable this if you forward HTTPS traffic to unicorn,
    # this helps Rack set the proper URL scheme for doing redirects:
    proxy_set_header X-Forwarded-Proto $scheme;

    # pass the Host: header from the client right along so redirects
    # can be set properly within the Rack application
    proxy_set_header Host $http_host;

    # we don't want nginx trying to do something clever with
    # redirects, we set the Host: header above already.
    proxy_redirect off;

    location / {
      error_page 500 502 504 /500.html;

      client_max_body_size 4G;
      keepalive_timeout 10;

      if ($key_type != "web_api") {
        return 401; # invalid web_api certificate supplied
      }
      if ($analyst_token = "") {
        return 401; # missing analyst token from the key
      }

      gzip on;
      gzip_comp_level 6;
      gzip_min_length 4096;
      gzip_proxied any;
      gzip_types text/plain application/json text/xml application/xml text/csv;

      proxy_set_header  analyst-token $analyst_token;

      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

      proxy_read_timeout 150s;

      # enable this if you forward HTTPS traffic to unicorn,
      # this helps Rack set the proper URL scheme for doing redirects:
      proxy_set_header X-Forwarded-Proto $scheme;

      # pass the Host: header from the client right along so redirects
      # can be set properly within the Rack application
      proxy_set_header Host $http_host;

      # we don't want nginx trying to do something clever with
      # redirects, we set the Host: header above already.
      proxy_redirect off;

      # Note: all requests to this location are redirected to /api
      proxy_pass http://127.0.0.1:3000/api/;
    }

    location ~* ^/tasks/(?<task_token>\w*)/results {
      error_page 500 502 504 /500.html;

      client_max_body_size 4G;
      keepalive_timeout 10;

      if ($key_type != "web_api") {
        return 401; # invalid web_api certificate supplied
      }
      if ($analyst_token = "") {
        return 401; # missing analyst token from the key
      }

      gzip on;
      gzip_comp_level 6;
      gzip_min_length 4096;
      gzip_proxied any;
      gzip_types text/plain application/json text/xml application/xml text/csv;

      proxy_set_header  analyst-token $analyst_token;

      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

      proxy_read_timeout 150s;

      # enable this if you forward HTTPS traffic to unicorn,
      # this helps Rack set the proper URL scheme for doing redirects:
      proxy_set_header X-Forwarded-Proto $scheme;

      # pass the Host: header from the client right along so redirects
      # can be set properly within the Rack application
      proxy_set_header Host $http_host;

      # we don't want nginx trying to do something clever with
      # redirects, we set the Host: header above already.
      proxy_redirect off;

      # Note: all requests to this location are redirected to /api
      proxy_pass http://127.0.0.1:11000/backend/api/tasks/$task_token/results?$is_args$args;
    }
  }
}
