defmodule Mix.Tasks.Proper do
  @shortdoc "Runs PropEr tests"
  @moduledoc """
  Mix task for running PropEr tests.

  You can start the task from the command line with `mix proper`. Only the modules which
  export the `proper` attribute will be tested. In other words, in your module
  you need to include following:

  ```erlang
  -proper(some_level).
  ```

  Where `some_level` is an arbitrary atom specifying the test level. By default, all
  levels are included in the test run, but you can use the --level target_level` to
  run tests from the provided level only.

  To test a single module, you can run `mix proper --module target_module`. This
  will run tests specified in the `target_module_test` module.
  """
  use Mix.Task

  # Mix.Task behaviour is not in PLT since Mix is not a runtime dep, so we disable the warning
  @dialyzer :no_undefined_callbacks

  @recursive true

  @impl Mix.Task
  def run(args) do
    project_config = Mix.Project.config

    # It seems that modules are already loaded at this point, so proper doesn't pick up new versions if the
    # code is changed. To fix this, we're reloading all modules of this app.
    for {module, path} <- :code.all_loaded,
        String.starts_with?(to_string(path), "#{Mix.Project.build_path}/lib/#{project_config[:app]}/ebin/")
    do
      :code.purge(module)
      :code.soft_purge(module)
      {:module, _} = :code.load_file(module)
    end

    Mix.Task.run("loadpaths", args)
    Mix.Task.run("app.start", args)

    {options, _, _} = OptionParser.parse(args)
    modules = case options[:module] do
      nil -> all_proper_modules(project_config, String.to_atom(options[:level] || "all"))
      module -> [:"#{module}_test"]
    end

    errors =
      for module <- modules,
          proper_result = :proper.module(module, on_output: &on_output/2),
          proper_result != [],
          do: module

    System.at_exit(fn(_) -> if errors != [], do: exit({:shutdown, 1}) end)

    :ok
  end

  # Suppresses a warning generated by Elixir's comprehension
  @dialyzer {:no_match, all_proper_modules: 2}
  defp all_proper_modules(project_config, level) do
    for beam_name <- Path.wildcard("#{Mix.Project.build_path}/lib/#{project_config[:app]}/ebin/*.beam"),
        module_name = Path.basename(beam_name, ".beam"),
        not String.starts_with?(module_name, "Elixir"),
        module = String.to_atom(module_name),
        Enum.any?(Keyword.keys(module.module_info(:exports)), &String.starts_with?(to_string(&1), "prop_")),
        include?(module.module_info(:attributes)[:proper], level),
        do: module
  end

  defp include?(nil, _), do: false
  defp include?(_, :all), do: true
  defp include?([level], level), do: true
  defp include?(_, _), do: false

  # Suppress history term, because it was causing a lot of noise
  defp on_output('~w~n', _params), do: :ok
  defp on_output(format, params), do: :io.format(format, params)
end
