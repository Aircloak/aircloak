defmodule Central.CustomerMessage do
  @moduledoc "Decoding and handling of messages sent by air."
  require Logger
  alias Central.Service.Customer


  # -------------------------------------------------------------------
  # API functions
  # -------------------------------------------------------------------

  @doc "Imports the data generated by the manual export."
  @spec import_customer_data(binary) :: {:ok, pos_integer} | {:error, :invalid_format | :invalid_token}
  def import_customer_data(air_export) do
    with {:ok, export} <- decode_exported_data(air_export),
         {:ok, customer} <- Customer.from_token(export.customer_token) do
      Enum.each(export.rpcs, &handle(&1, customer, export.air_name))
      {:ok, length(export.rpcs)}
    end
  end

  @doc "Handles a message sent by the customer's air."
  @spec handle(map, Customer.t, String.t) :: any
  def handle(message, customer, air_name) do
    message_id = Map.fetch!(message, "id")
    case Customer.rpc(customer, air_name, message_id) do
      nil ->
        # We look for event_payload for backwards compatibility with older airs
        payload = message["payload"] || message["event_payload"]
        result = handle(message["event"], payload, customer, air_name)
        Customer.store_rpc!(customer, air_name, message_id, result)
        result

      rpc ->
        Logger.info("Received a repeat RPC call for RPC id '#{rpc.id}'. The RPC was not re-executed. " <>
          "The type of the incoming RPC was '#{message["event"]}'")
        :erlang.binary_to_term(rpc.result)
    end
  end


  # -------------------------------------------------------------------
  # Internal functions
  # -------------------------------------------------------------------

  defp decode_exported_data(air_export) do
    try do
      %{id: id, payload: payload} = :erlang.binary_to_term(air_export)

      %{
        "last_exported_id" => last_exported_id,
        "air_name" => air_name,
        "customer_token" => customer_token,
        "rpcs" => rpcs,
      } =
        payload
        |> :zlib.gunzip()
        |> Poison.decode!()

      {:ok, %{
        id: id,
        last_exported_id: last_exported_id,
        air_name: air_name,
        customer_token: customer_token,
        rpcs: rpcs,
      }}
    catch type, error ->
      Logger.error([
        "Error decoding import data: #{inspect(type)}:#{inspect(error)}\n",
        Exception.format_stacktrace(System.stacktrace())
      ])
      {:error, :invalid_format}
    end
  end

  defp handle("query_execution", payload, customer, _air_name) do
    Logger.info("Received query execution update with payload: #{inspect payload}")
    customer = customer
    params = %{
      metrics: payload["metrics"],
      features: payload["features"],
      aux: payload["aux"],
    }
    Customer.record_query(customer, params)
  end
  defp handle("cloak_online", cloak_info, customer, air_name) do
    Central.Service.Customer.update_cloak(customer, air_name,
      Map.fetch!(cloak_info, "name"),
      status: :online, data_source_names: Map.get(cloak_info, "data_source_names", []),
        version: Map.get(cloak_info, "version", "Unknown")
    )
    :ok
  end
  defp handle("cloak_offline", cloak_info, customer, air_name) do
    Central.Service.Customer.update_cloak(customer, air_name,
      Map.fetch!(cloak_info, "name"), status: :offline)
    :ok
  end
  defp handle("usage_info", uptime_info, customer, air_name) do
    Central.Service.Customer.store_uptime_info(
      customer,
      air_name,
      NaiveDateTime.from_iso8601!(Map.fetch!(uptime_info, "air_utc_time")),
      Map.delete(uptime_info, "air_utc_time")
    )
    :ok
  end
  defp handle(other, data, _customer, _air_name) do
    Logger.warn("unknown call `#{other}` (#{inspect(data)})")
    # Responding with ok, because the client can't fix this issue by retrying
    :ok
  end
end
