defmodule Central.Service.Customer do
  @moduledoc "Service module for working with users"

  require Logger
  require Aircloak.DeployConfig

  alias Ecto.Changeset
  alias Central.Repo
  alias Central.Schemas.{AirRPC, Customer, CustomerExport, Query, License}
  alias Central.Service.ElasticSearch
  alias Central.Service.Customer.AirMessage

  import Ecto.Query, only: [from: 2]

  @message_handler_sup Module.concat(__MODULE__, MessageHandler.Supervisor)


  # -------------------------------------------------------------------
  # API functions
  # -------------------------------------------------------------------

  @doc "Imports the data generated by the manual export."
  @spec import_customer_data(binary) ::
    {:ok, pos_integer} | {:error, AirMessage.import_error} | {:error, :invalid_version}
  def import_customer_data(air_export) do
    with {:ok, export} <- AirMessage.decode_exported_data(air_export),
         {:ok, license} <- Central.Service.License.decrypt(export.license),
         {:ok, customer} <- from_license(license),
         :ok <- AirMessage.validate_export(customer, export),
         {:ok, handler} <- air_handler(export.air_version)
        do
      {:ok, _} = Repo.transaction(
        fn ->
          try do
            # We don't need to check for duplicate rpcs, because we verified that the export has not already been
            # imported, and because the export is imported atomically (all or nothing).
            num_rpcs = length(export.rpcs)
            export.rpcs
            |> Stream.with_index()
            |> Enum.each(fn({rpc, index}) ->
                if rem(index + 1, 1000) == 0, do: Logger.info("importing rpc ##{index+1}/#{num_rpcs}")
                handler.handle(rpc, customer, export.air_name, check_duplicate_rpc?: false)
              end)

            mark_export_as_imported!(customer, export.id, export.created_at)
          catch type, error ->
            Logger.error(Exception.format(type, error, :erlang.get_stacktrace()))
            Repo.rollback(:error)
          end
        end,
        timeout: :timer.minutes(10)
      )
      {:ok, length(export.rpcs)}
    end
  end

  @doc "Starts an asynchronous handler of an Air message."
  @spec start_air_message_handler(AirMessage.rpc, Customer.t, String.t, String.t) :: {:ok, pid}
  def start_air_message_handler(message, customer, air_name, air_version), do:
    Task.Supervisor.start_child(@message_handler_sup, fn() ->
      {:ok, handler} = air_handler(air_version)
      handler.handle(message, customer, air_name, check_duplicate_rpc?: true)
    end)

  @doc "Returns all registered customers"
  @spec all() :: [Customer.t]
  def all(), do:
    Repo.all(Customer)

  @doc "Creates a customer"
  @spec create(Map.t) :: {:ok, Customer.t} | {:error, Changeset.t}
  def create(params) do
    changeset = Customer.new_customer_changeset(Customer.empty_changeset(), params)
    Repo.insert(changeset)
  end

  @doc "Updates a customer"
  @spec update(Customer.t, Map.t) :: {:ok, Customer.t} | {:error, Changeset.t}
  def update(customer, params) do
    changeset = Customer.changeset(customer, params)
    Repo.update(changeset)
  end

  @doc "Removes a customer"
  @spec delete(Customer.t) :: :ok | :error
  def delete(customer) do
    case Repo.delete(customer) do
      {:ok, _} -> :ok
      {:error, _changeset} -> :error
    end
  end

  @doc "Returns a customer by id"
  @spec get(non_neg_integer) :: {:ok, Customer.t} | {:error, :not_found}
  def get(id) do
    case Repo.get(Customer, id) do
      nil -> {:error, :not_found}
      customer -> {:ok, customer}
    end
  end

  @doc """
  Generates a cryptographically signed token that is tied to a customer, and can
  be used to identify a customer through APIs.
  """
  @spec generate_token(Customer.t) :: {:ok, String.t}
  def generate_token(customer) do
    {:ok, Phoenix.Token.sign(secret_key_base(), customer_token_salt(), customer.id)}
  end

  @doc """
  Returns the customer associated with a token.
  Returns an error either if the customer doesn't exist, and likewise
  if the token is invalid.
  """
  @spec from_token(String.t) :: {:ok, Customer.t} | {:error, :invalid_token}
  def from_token(token) do
    case Phoenix.Token.verify(secret_key_base(), customer_token_salt(), token, max_age: almost_infinity()) do
      {:ok, customer_id} ->
        case get(customer_id) do
          {:error, :not_found} -> {:error, :invalid_token}
          other -> other
        end
      _ -> {:error, :invalid_token}
    end
  end

  @doc """
  Returns the customer associated with the given license.
  """
  @spec from_license(License.t) :: {:ok, Customer.t} | :error
  def from_license(license) do
    Customer
    |> Repo.get(license.customer_id)
    |> case do
      nil -> :error
      customer -> {:ok, customer}
    end
  end

  @doc "Records a query execution associated with a customer"
  @spec record_query(Customer.t, Map.t) :: :ok | :error
  def record_query(customer, params) do
    ElasticSearch.record_query(customer, params)
    changeset = customer
      |> Ecto.build_assoc(:queries)
      |> Query.changeset(params)
    case Repo.insert(changeset) do
      {:ok, _} -> :ok
      {:error, changeset} ->
        Logger.error("Failed to insert query for customer #{customer.name} (#{customer.id}): " <>
          inspect(changeset))
        :error
    end
  end

  @doc "Returns true if the given export has been imported"
  @spec imported?(Customer.t, integer) :: boolean
  def imported?(customer, export_id), do:
    Repo.one(from(c in CustomerExport, where: c.export_id == ^export_id and c.customer_id == ^customer.id)) != nil

  @doc "Returns the last imported export for the given customer."
  @spec most_recent_export(Customer.t) :: CustomerExport.t | nil
  def most_recent_export(customer), do:
    Repo.one(from c in CustomerExport,
      where: c.customer_id == ^customer.id,
      order_by: [desc: c.id],
      limit: 1
    )

  @doc "Determines if the RPC for the given customer, air, and with the given id is already imported."
  @spec rpc_imported?(Customer.t, String.t, String.t) :: boolean
  def rpc_imported?(customer, air_name, message_id), do:
    Repo.get(AirRPC, rpc_id(customer, air_name, message_id)) != nil

  @doc "Stores the RPC into the database."
  @spec store_rpc!(Customer.t, String.t, String.t) :: AirRPC.t
  def store_rpc!(customer, air_name, message_id), do:
    Repo.insert!(%AirRPC{id: rpc_id(customer, air_name, message_id)})

  @doc "Deletes old RPCs from the database."
  @spec delete_old_rpcs() :: :ok
  def delete_old_rpcs() do
    delete_after = -Application.fetch_env!(:central, :delete_air_rpcs_after)
    {num_deleted, _} = Repo.delete_all(
      from rpc in AirRPC,
        where: rpc.inserted_at < from_now(^delete_after, "millisecond")
    )
    Logger.info("deleted #{num_deleted} Air RPC entries from the database")
    :ok
  end


  # -------------------------------------------------------------------
  # Internal functions
  # -------------------------------------------------------------------

  defp almost_infinity(), do:
    # Phoenix warns if we're not validating the token age, so we need to pass some integer value.
    # Therefore, we're simulating infinity by using a ridiculously large value (10,000 years).
    60 * 60 * 24 * 365 * 10_000

  defp rpc_id(customer, air_name, message_id), do:
    Enum.join([customer.id, air_name, message_id], "|")

  defp customer_token_salt() do
    Central.site_setting("customer_token_salt")
  end

  defp secret_key_base() do
    Central.site_setting("endpoint_key_base")
  end

  defp mark_export_as_imported!(customer, export_id, created_at), do:
    Repo.insert!(%CustomerExport{export_id: export_id, created_at: created_at, customer: customer})

  defp air_handler("Unknown"), do: {:ok, AirMessage.Default}
  defp air_handler(air_version) do
    case Version.parse(air_version) do
      :error -> {:error, :invalid_version}
      {:ok, version} ->
        cond do
          Version.match?(version, ">=17.1.0 and <18.2.0") -> {:ok, AirMessage.Default}
          Version.match?(version, ">=18.2.0") -> {:ok, AirMessage.V180200}
          true -> {:error, :invalid_version}
        end
    end
  end


  # -------------------------------------------------------------------
  # Supervision tree
  # -------------------------------------------------------------------

  @doc false
  def child_spec(_arg), do:
    Aircloak.ChildSpec.task_supervisor([name: @message_handler_sup])
end
