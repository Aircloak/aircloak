defmodule Central.Service.Customer do
  @moduledoc "Service module for working with users"

  require Logger
  require Aircloak.DeployConfig

  alias Ecto.Changeset
  alias Central.Repo
  alias Central.Schemas.{Air, AirRPC, Cloak, Customer, CustomerExport, Query, OnlineStatus}
  alias Central.Service.ElasticSearch
  alias Central.Service.Customer.Message

  import Ecto.Query, only: [from: 2]


  #-----------------------------------------------------------------------------------------------------------
  # API functions
  #-----------------------------------------------------------------------------------------------------------

  @doc "Imports the data generated by the manual export."
  @spec import_customer_data(binary) :: {:ok, pos_integer} | {:error, Message.import_error}
  def import_customer_data(air_export) do
    with {:ok, export} <- Message.decode_exported_data(air_export),
         {:ok, customer} <- from_token(export.customer_token),
         :ok <- Message.validate_export(customer, export)
        do
      Enum.each(export.rpcs, &handle_air_message(&1, customer, export.air_name))
      mark_export_as_imported!(customer, export.id, export.created_at)
      {:ok, length(export.rpcs)}
    end
  end

  @doc "Handles a message sent by the customer's air."
  @spec handle_air_message(Message.rpc, Customer.t, String.t) :: Message.message_result
  def handle_air_message(message, customer, air_name) do
    message_id = Map.fetch!(message, "id")
    case rpc(customer, air_name, message_id) do
      nil ->
        # We look for event_payload for backwards compatibility with older airs
        payload = message["payload"] || message["event_payload"]
        result = Message.handle(message["event"], payload, customer, air_name)
        store_rpc!(customer, air_name, message_id, result)
        result

      rpc ->
        Logger.info("Received a repeat RPC call for RPC id '#{rpc.id}'. The RPC was not re-executed. " <>
          "The type of the incoming RPC was '#{message["event"]}'")
        :erlang.binary_to_term(rpc.result)
    end
  end

  @doc "Returns all registered customers"
  @spec all() :: [Customer.t]
  def all() do
    Repo.all(from Customer, preload: [{:airs, :cloaks}])
  end

  @doc "Creates a customer"
  @spec create(Map.t) :: {:ok, Customer.t} | {:error, Changeset.t}
  def create(params) do
    changeset = Customer.new_customer_changeset(Customer.empty_changeset(), params)
    Repo.insert(changeset)
  end

  @doc "Updates a customer"
  @spec update(Customer.t, Map.t) :: {:ok, Customer.t} | {:error, Changeset.t}
  def update(customer, params) do
    changeset = Customer.changeset(customer, params)
    Repo.update(changeset)
  end

  @doc "Removes a customer"
  @spec delete(Customer.t) :: :ok | :error
  def delete(customer) do
    case Repo.delete(customer) do
      {:ok, _} -> :ok
      {:error, _changeset} -> :error
    end
  end

  @doc "Returns a cusstomer by id"
  @spec get(non_neg_integer) :: {:ok, Customer.t} | {:error, :not_found}
  def get(id) do
    case Repo.get(Customer, id) do
      nil -> {:error, :not_found}
      customer -> {:ok, Repo.preload(customer, [{:airs, :cloaks}])}
    end
  end

  @doc """
  Generates a cryptographically signed token that is tied to a customer, and can
  be used to identify a customer through APIs.
  """
  @spec generate_token(Customer.t) :: {:ok, String.t}
  # The dialyzer suppression is due to a bug in Phoenix whereby :milli_seconds
  # is used instead of :milliseconds. This has been fixed in more recent
  # versions of Phoenix: https://github.com/phoenixframework/phoenix/pull/1986
  @dialyzer :no_return
  def generate_token(customer) do
    {:ok, Phoenix.Token.sign(secret_key_base(), customer_token_salt(), customer.id)}
  end

  @doc """
  Returns the customer associated with a token.
  Returns an error either if the customer doesn't exist, and likewise
  if the token is invalid.
  """
  @spec from_token(String.t) :: {:ok, Customer.t} | {:error, :invalid_token}
  def from_token(token) do
    case Phoenix.Token.verify(secret_key_base(), customer_token_salt(), token) do
      {:ok, customer_id} ->
        case get(customer_id) do
          {:error, :not_found} -> {:error, :invalid_token}
          other -> other
        end
      _ -> {:error, :invalid_token}
    end
  end

  @doc "Records a query execution associated with a customer"
  @spec record_query(Customer.t, Map.t) :: :ok | :error
  def record_query(customer, params) do
    ElasticSearch.record_query(customer, params)
    changeset = customer
      |> Ecto.build_assoc(:queries)
      |> Query.changeset(params)
    case Repo.insert(changeset) do
      {:ok, _} -> :ok
      {:error, changeset} ->
        Logger.error("Failed to insert query for customer #{customer.name} (#{customer.id}): " <>
          inspect(changeset))
        :error
    end
  end

  @doc "Marks air and associated cloaks as online."
  @spec mark_air_online(Customer.t, String.t, Central.AirStats.air_info) :: :ok
  def mark_air_online(customer, air_name, air_info) do
    {:ok, air} = Repo.transaction(fn ->
      version = air_info[:air_version]
      air = Repo.insert!(
        %Air{name: air_name, customer: customer, status: :online, version: version},
        on_conflict: [set: [status: :online, version: version]],
        conflict_target: [:name, :customer_id]
      )
      air_info[:online_cloaks]
      |> Enum.each(&update_cloak(customer, air_name, &1.name,
        status: :online, data_source_names: &1.data_source_names, version: &1.version))
      air
    end)

    ElasticSearch.record_air_presence(air)

    :ok
  end

  @doc "Marks air and all known cloaks as offline."
  @spec mark_air_offline(Customer.t, String.t) :: :ok
  def mark_air_offline(customer, air_name) do
    {:ok, air} = Repo.transaction(fn ->
      air = Repo.insert!(
        %Air{name: air_name, customer: customer, status: :offline, version: "Unknown"},
        on_conflict: [set: [status: :offline]],
        conflict_target: [:name, :customer_id]
      )
      Repo.update_all(from(c in Cloak, where: c.air_id == ^air.id), set: [status: :offline])
      air
    end)

    ElasticSearch.record_air_presence(air)

    :ok
  end

  # Error in current Ecto: https://github.com/elixir-ecto/ecto/issues/1882
  @dialyzer {:no_opaque, reset_air_statuses: 0}
  @doc "Resets statuses of all known airs and associated cloaks to offline."
  @spec reset_air_statuses() :: :ok
  def reset_air_statuses() do
    {:ok, _} =
      Ecto.Multi.new()
      |> Ecto.Multi.update_all(:set_airs_offline, Air, set: [status: :offline])
      |> Ecto.Multi.update_all(:set_cloaks_offline, Cloak, set: [status: :offline])
      |> Repo.transaction()

    :ok
  end

  @doc "Returns the list of all known airs."
  @spec airs() :: [Air.t]
  def airs(), do:
    Repo.all(from Air, preload: [:customer, :cloaks])

  @doc "Updates the cloak status."
  @spec update_cloak(Customer.t, String.t, String.t,
      [status: OnlineStatus.t, data_source_names: [String.t], version: String.t]) :: :ok
  def update_cloak(customer, air_name, cloak_name, updates) do
    cloak = Map.merge(
      %Cloak{air: Repo.get_by!(Ecto.assoc(customer, :airs), name: air_name), name: cloak_name},
      updates |> Enum.into(%{})
    )
    Repo.insert!(cloak, on_conflict: [set: updates], conflict_target: [:name, :air_id])

    :ok
  end

  @doc "Stores the uptime info sent from air."
  @spec store_uptime_info(Customer.t, String.t, NaiveDateTime.t, Map.t) :: :ok
  def store_uptime_info(customer, air_name, air_utc_time, data) do
    mtime = NaiveDateTime.utc_now()

    Repo.insert_all("usage_info", [[
      customer_id: customer.id,
      air_id: Repo.get_by!(Ecto.assoc(customer, :airs), name: air_name).id,
      air_utc_time: air_utc_time,
      data: data,
      inserted_at: mtime,
      updated_at: mtime,
    ]])

    :ok
  end

  @doc "Retrieves an RPC identified by the given id."
  @spec rpc(Customer.t, String.t, String.t) :: nil | AirRPC.t
  def rpc(customer, air_name, message_id), do:
    Repo.get(AirRPC, rpc_id(customer, air_name, message_id))

  @doc "Stores an RPC into the database."
  @spec store_rpc!(Customer.t, String.t, String.t, any) :: AirRPC.t
  def store_rpc!(customer, air_name, message_id, result), do:
    %AirRPC{}
    |> AirRPC.changeset(%{id: rpc_id(customer, air_name, message_id), result: :erlang.term_to_binary(result)})
    |> Repo.insert!()

  @doc "Marks export as imported."
  @spec mark_export_as_imported!(Customer.t, integer, NaiveDateTime.t) :: :ok
  def mark_export_as_imported!(customer, export_id, created_at) do
    Repo.insert!(%CustomerExport{export_id: export_id, created_at: created_at, customer: customer})
    :ok
  end

  @doc "Returns true if the given export has been imported"
  @spec imported?(Customer.t, integer) :: boolean
  def imported?(customer, export_id), do:
    Repo.one(from(c in CustomerExport, where: c.export_id == ^export_id and c.customer_id == ^customer.id)) != nil

  @doc "Returns the last imported export for the given customer."
  @spec most_recent_export(Customer.t) :: CustomerExport.t | nil
  def most_recent_export(customer), do:
    Repo.one(from c in CustomerExport,
      where: c.customer_id == ^customer.id,
      order_by: [desc: c.id],
      limit: 1
    )


  # -------------------------------------------------------------------
  # Internal functions
  # -------------------------------------------------------------------

  defp customer_token_salt() do
    Central.site_setting("customer_token_salt")
  end

  defp secret_key_base() do
    Central.site_setting("endpoint_key_base")
  end

  defp rpc_id(customer, air_name, message_id), do:
    Enum.join([customer.id, air_name, message_id], "|")
end
