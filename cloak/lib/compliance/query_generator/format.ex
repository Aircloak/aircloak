defmodule Cloak.Compliance.QueryGenerator.Format do
  @moduledoc "Pretty-prints SQL generated by the query generator."

  @line_width 80

  @infix_operator ~w(= <> < > like ilike not_like not_ilike in not_in)a

  import Inspect.Algebra

  # -------------------------------------------------------------------
  # API functions
  # -------------------------------------------------------------------

  @doc "Formats the given AST using Elixir's document algebra."
  @spec ast_to_sql(Cloak.Compliance.QueryGenerator.ast()) :: String.t()
  def ast_to_sql(ast), do: ast |> to_doc() |> Inspect.Algebra.format(@line_width) |> to_string()

  # -------------------------------------------------------------------
  # Internal functions
  # -------------------------------------------------------------------

  defp to_doc({:query, _, items}),
    do:
      items
      |> Enum.reject(&match?({:empty, _, _}, &1))
      |> Enum.map(fn item -> item |> to_doc() |> nest() end)
      |> space_separated()

  defp to_doc({:select, nil, select_list}), do: "SELECT" |> glue(" ", clause_list(select_list)) |> group()

  defp to_doc({:from, nil, [from_expression]}), do: glue("FROM", " ", to_doc(from_expression))

  defp to_doc({:table, name, []}), do: name

  defp to_doc({:subquery, nil, [definition]}),
    do: "(" |> glue("", to_doc(definition)) |> nest() |> glue("", ")") |> group()

  defp to_doc({:join, nil, [lhs, rhs, on]}),
    do: fold_doc([to_doc(lhs), "JOIN", to_doc(rhs), to_doc(on)], &glue(&1, " ", &2))

  defp to_doc({:on, nil, [condition]}), do: space_separated(["ON", to_doc(condition)])

  defp to_doc({:as, name, [object]}), do: concat([to_doc(object), " AS ", name])

  defp to_doc({:where, nil, [condition]}), do: space_separated(["WHERE", to_doc(condition)])

  defp to_doc({:group_by, nil, group_list}), do: "GROUP BY" |> glue(" ", clause_list(group_list)) |> group()

  defp to_doc({:having, nil, [condition]}), do: glue("HAVING", " ", to_doc(condition))

  defp to_doc({op, nil, [lhs, rhs]}) when op in @infix_operator,
    do: operator(to_doc(lhs), binary_operation_to_string(op), to_doc(rhs))

  defp to_doc({:between, nil, [lhs, low, high]}),
    do: space_separated([to_doc(lhs), "BETWEEN", to_doc(low), "AND", to_doc(high)])

  defp to_doc({:and, nil, [lhs, rhs]}), do: concat(["(", operator(to_doc(lhs), "AND", to_doc(rhs)), ")"])

  defp to_doc({:or, nil, [lhs, rhs]}), do: concat(["(", operator(to_doc(lhs), "OR", to_doc(rhs)), ")"])

  defp to_doc({:function, name, args}),
    do:
      name
      |> concat("(")
      |> glue("", args |> Enum.map(&to_doc/1) |> comma_separated())
      |> nest()
      |> glue("", ")")
      |> group()

  defp to_doc({:column, {column, table}, []}), do: to_string([?", table, ?", ?., ?", column, ?"])
  defp to_doc({:integer, value, []}), do: to_string(value)
  defp to_doc({:text, value, []}), do: to_string([?', value, ?'])
  defp to_doc({:boolean, value, []}), do: to_string(value)
  defp to_doc({:datetime, value, []}), do: to_string([?', to_string(value), ?'])
  defp to_doc({:time, value, []}), do: to_string([?', to_string(value), ?'])
  defp to_doc({:date, value, []}), do: to_string([?', to_string(value), ?'])
  defp to_doc({:interval, value, []}), do: to_string(["interval ", ?', Timex.Duration.to_string(value), ?'])
  defp to_doc({:real, value, []}), do: to_string(value)

  defp to_doc({:like_pattern, value, [escape]}), do: space_separated([to_string([?', value, ?']), to_doc(escape)])

  defp to_doc({:like_escape, char, []}), do: space_separated(["ESCAPE", to_string([?', char, ?'])])

  defp to_doc({:in_set, nil, items}),
    do:
      container_doc(
        "(",
        items,
        ")",
        %Inspect.Opts{limit: :infinity},
        fn item, _opts -> to_doc(item) end,
        separator: ","
      )

  defp to_doc({:star, _, _}), do: "*"
  defp to_doc({:empty, _, _}), do: empty()

  defp to_doc({:sample_users, size, []}), do: concat(["SAMPLE_USERS ", to_string(size), "%"])

  defp binary_operation_to_string(:=), do: "="
  defp binary_operation_to_string(:<), do: "<"
  defp binary_operation_to_string(:>), do: ">"
  defp binary_operation_to_string(:<>), do: "<>"
  defp binary_operation_to_string(:like), do: "LIKE"
  defp binary_operation_to_string(:ilike), do: "ILIKE"
  defp binary_operation_to_string(:not_like), do: "NOT LIKE"
  defp binary_operation_to_string(:not_ilike), do: "NOT ILIKE"
  defp binary_operation_to_string(:in), do: "IN"
  defp binary_operation_to_string(:not_in), do: "NOT IN"

  defp clause_list(ast_fragments), do: ast_fragments |> Enum.map(&to_doc/1) |> comma_separated()

  defp comma_separated(docs), do: docs |> fold_doc(&glue(concat(&1, ","), " ", &2)) |> group()

  defp space_separated(docs), do: docs |> fold_doc(&glue(&1, " ", &2)) |> group()

  defp nest(doc), do: doc |> group() |> nest(2)

  defp operator(doc1, operator, doc2), do: glue(concat([doc1, " ", operator]), " ", doc2) |> nest()
end
