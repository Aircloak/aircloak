defmodule Cloak.Compliance.QueryGenerator.Format do
  @moduledoc "Pretty-prints SQL generated by the query generator."

  @line_width 80

  @infix_operator ~w(= <> < > like ilike not_like not_ilike in not_in)a

  import Inspect.Algebra

  # -------------------------------------------------------------------
  # API functions
  # -------------------------------------------------------------------

  @doc "Formats the given AST using Elixir's document algebra."
  @spec ast_to_sql(Cloak.Compliance.QueryGenerator.ast()) :: String.t()
  def ast_to_sql(ast), do: ast |> to_doc() |> Inspect.Algebra.format(@line_width) |> to_string()

  # -------------------------------------------------------------------
  # Internal functions
  # -------------------------------------------------------------------

  defp to_doc({:query, _, items}),
    do:
      items
      |> except_empty()
      |> Enum.map(fn item -> item |> to_doc() |> nest() end)
      |> space_separated()

  defp to_doc({:select, nil, items}), do: "SELECT" |> glue(" ", clause_list(items)) |> group()

  defp to_doc({:from, nil, [from_expression]}), do: glue("FROM", " ", to_doc(from_expression))

  defp to_doc({:table, name, []}), do: name

  defp to_doc({:subquery, nil, [definition]}),
    do: "(" |> glue("", to_doc(definition)) |> nest() |> glue("", ")") |> group()

  defp to_doc({:join, nil, [lhs, rhs, on]}),
    do: fold_doc([to_doc(lhs), "JOIN", to_doc(rhs), to_doc(on)], &glue(&1, " ", &2))

  defp to_doc({:on, nil, [condition]}), do: space_separated(["ON", to_doc(condition)])

  defp to_doc({:as, name, [object]}), do: concat([to_doc(object), " AS ", name])

  defp to_doc({:where, nil, [condition]}), do: space_separated(["WHERE", to_doc(condition)])

  defp to_doc({:group_by, nil, group_list}), do: "GROUP BY" |> glue(" ", clause_list(group_list)) |> group()

  defp to_doc({:having, nil, [condition]}), do: glue("HAVING", " ", to_doc(condition))

  defp to_doc({:order_by, nil, order_list}), do: "ORDER BY" |> glue(" ", clause_list(order_list)) |> group()

  defp to_doc({:order_spec, nil, items}), do: items |> except_empty() |> Enum.map(&to_doc/1) |> space_separated()

  defp to_doc({:order_direction, direction, []}), do: direction |> to_string() |> String.upcase()

  defp to_doc({:nulls, directive, []}), do: concat("NULLS ", directive |> to_string() |> String.upcase())

  defp to_doc({op, nil, [lhs, rhs]}) when op in @infix_operator,
    do: operator(to_doc(lhs), binary_operation_to_string(op), to_doc(rhs))

  defp to_doc({:between, nil, [lhs, low, high]}),
    do: space_separated([to_doc(lhs), "BETWEEN", to_doc(low), "AND", to_doc(high)])

  defp to_doc({:and, nil, [lhs, rhs]}), do: concat(["(", operator(to_doc(lhs), "AND", to_doc(rhs)), ")"])

  defp to_doc({:or, nil, [lhs, rhs]}), do: concat(["(", operator(to_doc(lhs), "OR", to_doc(rhs)), ")"])

  defp to_doc({:not, nil, [expression]}),
    do: "NOT (" |> glue("", to_doc(expression)) |> nest() |> glue("", ")") |> group()

  defp to_doc({:function, name, [lhs, rhs]}) when name in ~w(+ - * / ^ %) do
    "("
    |> glue("", to_doc(lhs))
    |> glue(" ", name)
    |> glue(" ", to_doc(rhs))
    |> nest()
    |> glue("", ")")
    |> group()
  end

  defp to_doc({:function, {:cast, type}, [argument]}) do
    "CAST"
    |> concat("(")
    |> glue("", to_doc(argument))
    |> glue(" ", "AS")
    |> glue(" ", type |> to_string() |> String.upcase())
    |> nest()
    |> glue("", ")")
    |> group()
  end

  defp to_doc({:function, name, args}) do
    name
    |> concat("(")
    |> glue("", args |> except_empty() |> Enum.map(&to_doc/1) |> comma_separated())
    |> nest()
    |> glue("", ")")
    |> group()
  end

  defp to_doc({keyword_function, nil, args}) when keyword_function in [:substring, :bucket] do
    keyword_function
    |> to_string()
    |> String.upcase()
    |> concat("(")
    |> glue("", args |> Enum.map(&to_doc/1) |> space_separated())
    |> nest()
    |> glue("", ")")
    |> group()
  end

  defp to_doc({:many1, nil, arguments}), do: arguments |> Enum.map(&to_doc/1) |> comma_separated()

  defp to_doc({:keyword_arg, name, [value]}),
    do: name |> to_string() |> String.upcase() |> concat(" ") |> concat(to_doc(value))

  defp to_doc({:keyword, name, []}), do: name |> to_string() |> String.upcase()

  defp to_doc({:distinct, nil, [argument]}), do: concat("DISTINCT ", to_doc(argument))

  defp to_doc({:column, nil, [column]}), do: to_doc(column)
  defp to_doc({:column, nil, [table, column]}), do: concat([to_doc(table), ".", to_doc(column)])
  defp to_doc({:unquoted, text, []}), do: text
  defp to_doc({:quoted, text, []}), do: to_string([?", text, ?"])
  defp to_doc({:integer, value, []}), do: to_string(value)
  defp to_doc({:text, value, []}), do: to_string([?', value, ?'])
  defp to_doc({:boolean, value, []}), do: to_string(value)
  defp to_doc({:datetime, value, []}), do: to_string(["datetime ", ?', to_string(value), ?'])
  defp to_doc({:time, value, []}), do: to_string(["time ", ?', to_string(value), ?'])
  defp to_doc({:date, value, []}), do: to_string(["date ", ?', to_string(value), ?'])
  defp to_doc({:interval, value, []}), do: to_string(["interval ", ?', Timex.Duration.to_string(value), ?'])
  defp to_doc({:real, value, []}), do: to_string(value)

  defp to_doc({:like_pattern, value, [escape]}), do: space_separated([to_string([?', value, ?']), to_doc(escape)])

  defp to_doc({:like_escape, char, []}), do: space_separated(["ESCAPE", to_string([?', char, ?'])])

  defp to_doc({:in_set, nil, items}),
    do:
      container_doc(
        "(",
        items,
        ")",
        %Inspect.Opts{limit: :infinity},
        fn item, _opts -> to_doc(item) end,
        separator: ","
      )

  defp to_doc({:star, _, _}), do: "*"
  defp to_doc({:empty, _, _}), do: empty()

  defp to_doc({:limit, size, []}), do: concat("LIMIT ", to_string(size))
  defp to_doc({:offset, size, []}), do: concat("OFFSET ", to_string(size))

  defp binary_operation_to_string(:=), do: "="
  defp binary_operation_to_string(:<), do: "<"
  defp binary_operation_to_string(:>), do: ">"
  defp binary_operation_to_string(:<>), do: "<>"
  defp binary_operation_to_string(:like), do: "LIKE"
  defp binary_operation_to_string(:ilike), do: "ILIKE"
  defp binary_operation_to_string(:not_like), do: "NOT LIKE"
  defp binary_operation_to_string(:not_ilike), do: "NOT ILIKE"
  defp binary_operation_to_string(:in), do: "IN"
  defp binary_operation_to_string(:not_in), do: "NOT IN"

  defp clause_list(ast_fragments), do: ast_fragments |> Enum.map(&to_doc/1) |> comma_separated()

  defp comma_separated(docs), do: docs |> fold_doc(&glue(concat(&1, ","), " ", &2)) |> group()

  defp space_separated(docs), do: docs |> fold_doc(&glue(&1, " ", &2)) |> group()

  defp nest(doc), do: doc |> group() |> nest(2)

  defp operator(doc1, operator, doc2), do: glue(concat([doc1, " ", operator]), " ", doc2) |> nest()

  defp except_empty(items), do: Enum.reject(items, &match?({:empty, _, _}, &1))
end
