defmodule Compliance.VulnerabilityTest do
  use ComplianceCase, async: true

  @tag compliance: "vulnerability"
  test "divide by 0", context do
    assert_consistent_and_not_failing(context, "SELECT COUNT(*) FROM users_public WHERE 1/(height-height) IS NULL")
  end

  @tag compliance: "vulnerability"
  test "mod by 0", context do
    assert_consistent_and_not_failing(context, "SELECT COUNT(*) FROM users_public WHERE 1%trunc(age-age) IS NULL")
  end

  @tag compliance: "vulnerability"
  test "sqrt over negative input", context do
    assert_consistent_and_not_failing(context, "SELECT COUNT(*) FROM users_public WHERE sqrt(-age) IS NULL")
  end

  @tag compliance: "vulnerability"
  test "pow over negative input", context do
    assert_consistent_and_not_failing(context, "SELECT COUNT(*) FROM users_public WHERE -age^-0.5 IS NULL")
  end

  @tag compliance: "vulnerability"
  test "casting text to boolean", context do
    assert_consistent_and_not_failing(context, "SELECT COUNT(*) FROM users_public WHERE cast(name as boolean)")
  end

  @tag compliance: "vulnerability"
  test "casting large real values to integer", context do
    context
    # since Mongo doesn't support integers, casting does nothing
    |> disable_for(Cloak.DataSource.MongoDB, true)
    |> assert_consistent_and_not_failing(
      "SELECT COUNT(*) FROM users_public WHERE cast(height * 10.0^18 as integer) IS NULL"
    )
  end

  @tag compliance: "vulnerability"
  test "casting text to integer", context do
    context
    |> disable_for(Cloak.DataSource.Drill, true)
    |> disable_for(Cloak.DataSource.SAPHana, true)
    |> disable_for(Cloak.DataSource.Oracle, true)
    |> assert_consistent_and_not_failing("SELECT COUNT(*) FROM users_public WHERE cast(name as integer) > 0")
  end

  @tag compliance: "vulnerability"
  test "casting text to real", context do
    context
    |> disable_for(Cloak.DataSource.Drill, true)
    |> disable_for(Cloak.DataSource.SAPHana, true)
    |> disable_for(Cloak.DataSource.Oracle, true)
    |> assert_consistent_and_not_failing("SELECT COUNT(*) FROM users_public WHERE cast(name as real) > 0")
  end

  @tag compliance: "vulnerability"
  test "casting text to time", context do
    context
    |> disable_for(Cloak.DataSource.Drill, true)
    |> disable_for(Cloak.DataSource.SAPHana, true)
    |> disable_for(Cloak.DataSource.Oracle, true)
    |> assert_consistent_and_not_failing("SELECT COUNT(*) FROM users_public WHERE cast(name as time) = current_time()")
  end

  @tag compliance: "vulnerability"
  test "casting text to date", context do
    context
    |> disable_for(Cloak.DataSource.Drill, true)
    |> disable_for(Cloak.DataSource.SAPHana, true)
    |> disable_for(Cloak.DataSource.Oracle, true)
    |> assert_consistent_and_not_failing("SELECT COUNT(*) FROM users_public WHERE cast(name as date) = current_date()")
  end

  @tag compliance: "vulnerability"
  test "casting text to datetime", context do
    context
    |> disable_for(Cloak.DataSource.Drill, true)
    |> disable_for(Cloak.DataSource.SAPHana, true)
    |> disable_for(Cloak.DataSource.Oracle, true)
    |> assert_consistent_and_not_failing(
      "SELECT COUNT(*) FROM users_public WHERE cast(name as datetime) = current_datetime()"
    )
  end

  @tag compliance: "vulnerability"
  test "32-bit integer overflow", context do
    assert_consistent_and_not_failing(context, "SELECT age + 2147483647 AS val FROM users_public")
  end

  @max_allowed_int 999_999_999_999_999_999

  [
    "age * #{@max_allowed_int}",
    "age + #{1..10 |> Enum.map(fn _ -> @max_allowed_int end) |> Enum.join(" + ")}"
  ]
  |> Enum.each(fn snippet ->
    @tag compliance: "vulnerability"
    test "64-bit integer overflow in #{snippet}", context do
      assert_consistent_and_not_failing(context, "SELECT #{unquote(snippet)} AS val FROM users_public")
    end
  end)

  @tag compliance: "vulnerability"
  test "floating point overflow", context do
    assert_consistent_and_not_failing(context, "SELECT 2 ^ (age ^ 100.23) AS val FROM users_public")
  end
end
